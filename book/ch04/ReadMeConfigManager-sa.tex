\hypertarget{to-run-locally}{%
\subsection{To run locally:}\label{to-run-locally}}

\hypertarget{front-end-development}{%
\subsubsection{Front end development}\label{front-end-development}}

Install npm packages: \texttt{npm\ install} (You may have to restart
VSCode after this to pick up the installed components)

Generate the default configuration assets as .js files:
\texttt{npm\ run\ create-assets}

Compile the app and serve it via webpack-dev-server:
\texttt{npm\ run\ start-dev}

Chances are you'll need to open the app in a browser that has CORS
disabled (b/c the local frontend app will be hitting a deployed backend
(as opposed to a backend hosted locally). So this will produce a CORS
error). Run this command in a terminal to open a CORS-disabled version
of Chrome:
\texttt{open\ -n\ -a\ /Applications/Google\textbackslash{}\ Chrome.app/Contents/MacOS/Google\textbackslash{}\ Chrome\ -\/-args\ -\/-user-data-dir="/tmp/chrome\_dev\_test"\ -\/-disable-web-security}

build.sh is for production use only. It will throw errors if run
locally.

\hypertarget{back-end-development}{%
\subsubsection{Back end development}\label{back-end-development}}

If you have a standard backend setup and have setup the docker-dev admin
account, via

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{brew}\NormalTok{ install jp jo}
\BuiltInTok{cd}\NormalTok{ ~/Code/socotra-stack/docker-dev}
\FunctionTok{make}\NormalTok{ tenant}
\end{Highlighting}
\end{Shaded}

You will be able to run config manager locally along with Load Assets
and the API with the following procedure:

\begin{itemize}
\tightlist
\item
  Boot stack-api-service on port 8080 by running it through your IDE, as
  usual. Stack-api-services, directly, provides login services for
  config manager
\item
  Boot stack-load-assets on port 5000 by running the command
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{make}\NormalTok{ run}
\end{Highlighting}
\end{Shaded}

from the stack-load-assets base directory. Stack-load-assets provides
all of the asset publishing services for config manager.

\begin{itemize}
\tightlist
\item
  Boot stack-config-manager on port 9001 by running the command
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{make}\NormalTok{ run}
\end{Highlighting}
\end{Shaded}

from the stack-config-manager base directory.

When all three applications are running you should then be able to
navigate to \href{http://localhost:9001}{http://localhost:9001} in any
browser, login, and submit assets all within a local development
environment.

\hypertarget{directory-layout}{%
\subsection{Directory Layout:}\label{directory-layout}}

\begin{itemize}
\tightlist
\item
  assets: Contains default configurations artifacts (i.e. default
  config, default product)
\item
  public: Contains icons and image assets
\item
  sass: Contains sass files for styling. Currently trying to move over
  to a BEM-style methodology
\item
  src

  \begin{itemize}
  \item
    api: Contains code to make requests to backend APIs
  \item
    components: Contains our React components

    \begin{itemize}
    \tightlist
    \item
      actionpane: code for the actions sidebar
    \item
      actions: Contains the Actions of the Trigger-Action component
      design
    \item
      modals: Contains modal components
    \item
      pages: Contains pages and layouts
    \item
      popups: Contains popup components (i.e. action menus, dropdown
      menus). Distinct from modals in that modals are fullscreen and
      darken the bg. Popups and modals also currently use different
      underlying libraries for their implementation. They should
      probably be consolidated at some point.
    \item
      various other components not organized into the above folders
    \end{itemize}
  \item
    context: Contains state management code. We're using React's Context
    API for state management.
  \item
    models: Contains any complex data models (i.e. the configuration)
  \item
    util: Contains various utility code
  \end{itemize}
\item
  history.tsx: Specifies the history library to be used with
  react-router
\item
  main.tsx: The main entry point for the app
\item
  routes.tsx: Specifies the app's URL routes. Uses react-router
\end{itemize}

\hypertarget{trigger-action-component-design}{%
\subsection{Trigger-Action component
design}\label{trigger-action-component-design}}

This app contains numerous instances where we render some
user-interactable component (i.e. a button) and then when the user
interacts with it (i.e. clicks it), the app will perform some action.

The \textbf{Trigger} is the code for rendering the user-interactable
component.

The \textbf{Action} is the code for what happens when the user has
activated the Trigger.

\hypertarget{motivation}{%
\subsubsection{Motivation}\label{motivation}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  We often use the same trigger to do different actions. Ex: we use the
  same 'Remove' button as a trigger to remove different configuration
  items (i.e. we can remove products, exposures, perils, tables,
  documents, etc). Where the button appears contextually determines what
  item is being removed.
\item
  We use different triggers that end up performing the same action. Ex:
  We can clone a product from the Add New Product Modal or from the
  action menu on a specific product.
\item
  We sometimes want to chain actions together. We want an easy way to
  reuse actions in this scenario without requiring a rendered trigger
  for each action in the chain.
\end{enumerate}

\hypertarget{how-to-change-default-assets}{%
\subsection{How to change default
assets:}\label{how-to-change-default-assets}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Find the file in \texttt{assets/default} that you want to change.
\item
  Run \texttt{python\ generate\_default\_editor\_assets.py} for TS code
  gen.
\item
  Commit changes, and land them in \texttt{develop}. See: "more notes"
  below.
\end{enumerate}

If you want to test the change (much harder) using a locally built
image:

\begin{itemize}
\tightlist
\item
  Terminate containers w/
  \texttt{make\ stop\ -C\ \$REPO\_ROOT/socotra-stack/docker-dev}
\item
  Run the \texttt{Rakefile} target named
  \texttt{preenvironment:asset\_load\_server:build}
\end{itemize}

This copied the static files into the "load assets" project; rebuild the
image:

\begin{itemize}
\tightlist
\item
  \texttt{cd\ \$REPO\_ROOT/docker-loadassets;\ docker\ build\ .\ -t\ socotra/loadassets:master}
\item
  Restart containers w/
  \texttt{make\ services\ -C\ \$REPO\_ROOT/socotra-stack/docker-dev}
\end{itemize}

On \texttt{http://localhost:5000/studio/}, the container will now have
local changes.

\hypertarget{more-notes}{%
\subsection{More Notes}\label{more-notes}}

Since the user's changes are saved in-browser, you may need to:

\begin{verbatim}
localStorage.clear()
location.reload()
\end{verbatim}

If you have problems running \texttt{rake} try:

\begin{verbatim}
gem install httpclient java-properties vault
export RUBYLIB="$REPO_ROOT/socotra-stack/rakelib/lib"
\end{verbatim}

If \texttt{node} or \texttt{npm} complains, did you remember to:

\begin{verbatim}
nvm install lts/carbon # and do you have XCode installed?
export NPM_CONFIG_REGISTRY=https://registry.npmjs.org/
\end{verbatim}

Ask \#engineering after reading the scripts to troubleshoot problems:

\begin{verbatim}
cd $REPO_ROOT/socotra-stack && mkdir -p logs
rake preenvironment:asset_load_server:build -n
\end{verbatim}
